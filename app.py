# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mmg3wK8uBfv1wR-o3f4MZSCzlpMJzQzD
"""

import gradio as gr
from PIL import Image
import io, os, tempfile, zipfile, uuid, time, traceback

# ---------------- Helpers ----------------
def convert_size_to_bytes(value, unit):
    unit = unit.lower()
    if unit == "kb":
        return int(value * 1024)
    if unit == "mb":
        return int(value * 1024 * 1024)
    if unit == "gb":
        return int(value * 1024 * 1024 * 1024)
    return int(value)

def convert_to_rgb_for_jpeg(img):
    if img.mode in ("RGBA", "LA") or (img.mode == "P" and "transparency" in img.info):
        bg = Image.new("RGB", img.size, (255, 255, 255))
        alpha = img.convert("RGBA").split()[-1]
        bg.paste(img.convert("RGBA"), mask=alpha)
        return bg
    return img.convert("RGB")

def read_file_bytes(uf):
    """
    Robustly read uploaded file bytes from many possible shapes of 'uf'.
    Returns (bytes, original_name)
    """
    # 1) plain path string
    if isinstance(uf, str):
        if os.path.exists(uf):
            with open(uf, "rb") as f:
                return f.read(), os.path.basename(uf)
        raise ValueError("String provided but path does not exist: " + uf)

    # 2) object with .path attribute (common in Gradio UploadedFile)
    if hasattr(uf, "path") and uf.path and os.path.exists(uf.path):
        with open(uf.path, "rb") as f:
            return f.read(), getattr(uf, "name", os.path.basename(uf.path))

    # 3) object with tmp_path
    if hasattr(uf, "tmp_path") and uf.tmp_path and os.path.exists(uf.tmp_path):
        with open(uf.tmp_path, "rb") as f:
            return f.read(), getattr(uf, "name", os.path.basename(uf.tmp_path))

    # 4) dict-like
    if isinstance(uf, dict):
        if "data" in uf and isinstance(uf["data"], (bytes, bytearray)):
            name = uf.get("name", f"file_{uuid.uuid4().hex}")
            return bytes(uf["data"]), name
        if "tmp_path" in uf and os.path.exists(uf["tmp_path"]):
            with open(uf["tmp_path"], "rb") as f:
                return f.read(), uf.get("name", os.path.basename(uf["tmp_path"]))
        if "path" in uf and os.path.exists(uf["path"]):
            with open(uf["path"], "rb") as f:
                return f.read(), uf.get("name", os.path.basename(uf["path"]))

    # 5) file-like object
    if hasattr(uf, "read"):
        data = uf.read()
        if isinstance(data, str):
            data = data.encode("utf-8")
        return data, getattr(uf, "name", f"file_{uuid.uuid4().hex}")

    raise ValueError("Unsupported uploaded file object type: " + str(type(uf)))

def append_padding_to_file(path, target_bytes):
    """Append zero bytes to file at path until its size >= target_bytes."""
    cur = os.path.getsize(path)
    if cur >= target_bytes:
        return 0
    to_add = target_bytes - cur
    # write in chunks for efficiency
    chunk = b"\0" * 1024 * 64  # 64KB
    with open(path, "ab") as f:
        while to_add > 0:
            write_now = min(len(chunk), to_add)
            f.write(chunk[:write_now])
            to_add -= write_now
    return target_bytes - cur

# ---------------- Main Logic ----------------
def compress_images(uploaded_files, target_size, target_unit, output_format, allow_upsize):
    try:
        if not uploaded_files:
            return None, "No images uploaded."

        if not isinstance(uploaded_files, list):
            uploaded_files = [uploaded_files]

        target_bytes = convert_size_to_bytes(target_size, target_unit)
        tmpdir = tempfile.mkdtemp(prefix="compress_")
        output_paths = []
        logs = []

        for uf in uploaded_files:
            try:
                file_bytes, orig_name = read_file_bytes(uf)
            except Exception as e:
                logs.append(f"Could not read uploaded file: {e}")
                continue

            try:
                img = Image.open(io.BytesIO(file_bytes))
            except Exception as e:
                logs.append(f"Cannot open image {orig_name}: {e}")
                continue

            base = os.path.splitext(os.path.basename(orig_name))[0]
            ext = output_format.lower().lstrip(".")
            unique_token = uuid.uuid4().hex[:8]
            out_filename = f"{base}_{unique_token}.{ext}"
            out_path = os.path.join(tmpdir, out_filename)

            # Branch by format
            if ext in ("jpg", "jpeg", "webp"):
                img_rgb = convert_to_rgb_for_jpeg(img)
                quality = 95
                best_blob = None
                best_size = None
                best_q = None

                while quality >= 5:
                    buf = io.BytesIO()
                    if ext in ("jpg", "jpeg"):
                        img_rgb.save(buf, format="JPEG", quality=quality, optimize=True)
                    else:
                        img_rgb.save(buf, format="WEBP", quality=quality, method=6)

                    blob = buf.getvalue()
                    size_now = len(blob)

                    if best_blob is None or size_now < best_size:
                        best_blob = blob
                        best_size = size_now
                        best_q = quality

                    if size_now <= target_bytes:
                        with open(out_path, "wb") as f:
                            f.write(blob)
                        logs.append(f"{orig_name} → {out_filename} | {size_now/1024:.1f} Quality ={quality}")
                        output_paths.append(out_path)
                        break

                    quality -= 5

                else:
                    # never met target: save best-effort
                    if best_blob is not None:
                        with open(out_path, "wb") as f:
                            f.write(best_blob)
                        logs.append(f"{orig_name} → {out_filename} | best-effort {best_size/1024:.1f} KB Quality ={best_q}")
                        output_paths.append(out_path)
                    else:
                        logs.append(f"Failed to produce compressed blob for {orig_name}")

            elif ext == "png":
                buf = io.BytesIO()
                try:
                    img.save(buf, format="PNG", optimize=True)
                except Exception:
                    img.convert("RGBA").save(buf, format="PNG", optimize=True)
                blob = buf.getvalue()
                with open(out_path, "wb") as f:
                    f.write(blob)
                logs.append(f"{orig_name} → {out_filename} | {len(blob)/1024:.1f} KB (PNG optimized)")
                output_paths.append(out_path)
            else:
                buf = io.BytesIO()
                img.save(buf, format="PNG", optimize=True)
                blob = buf.getvalue()
                with open(out_path, "wb") as f:
                    f.write(blob)
                logs.append(f"{orig_name} → {out_filename} | saved as PNG (unknown requested format)")
                output_paths.append(out_path)

            # --- UPSIZING (Option C behavior) ---
            # If allow_upsize is True and the user requested a target bigger than current file,
            # append null bytes so final size >= target_bytes
            try:
                final_size = os.path.getsize(out_path)
                if allow_upsize and final_size < target_bytes:
                    added = append_padding_to_file(out_path, target_bytes)
                    final_after = os.path.getsize(out_path)
                    logs.append(f"↪ Upsized {os.path.basename(out_path)} by {added} bytes → {final_after/1024:.1f} KB (target was {target_bytes/1024:.1f} KB)")
            except Exception as e:
                logs.append(f" Upsizing failed for {out_filename}: {e}")

        # If nothing produced
        if not output_paths:
            return None, "\n".join(logs) or "No outputs produced."

        # If multiple outputs => zip them
        if len(output_paths) == 1:
            return output_paths[0], "\n".join(logs)
        else:
            zip_path = os.path.join(tmpdir, f"compressed_{int(time.time())}.zip")
            with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
                for p in output_paths:
                    zf.write(p, arcname=os.path.basename(p))
            return zip_path, "\n".join(logs)

    except Exception as e:
        tb = traceback.format_exc()
        return None, f"Unhandled error in compress_images(): {e}\n\nTraceback:\n{tb}"

# ---------------- UI ----------------
with gr.Blocks(
    theme=gr.themes.Base(),
    css="""
    body, .gradio-container {
        background-color: #ffffff !important;  /* your background color */
    }

    .gr-button {
        background-color: #4F46E5 !important;
        color: white !important;
        border-radius: 10px !important;
        padding: 8px 16px !important;
    }

    .gr-input, .gr-textbox, .gr-dropdown {
        background-color: #fff !important;
        border-radius: 8px !important;
    }

    """
) as demo:
    gr.Markdown("# Image Compressor — Upsize Option")

    with gr.Row():
        files_in = gr.File(label="Upload images", file_count="multiple", file_types=["image"])
        with gr.Column():
            target_value = gr.Number(value=300, label="Target Size")
            target_unit = gr.Dropdown(["KB", "MB", "GB"], value="KB", label="Unit")
            output_format = gr.Dropdown(["jpg", "jpeg", "png", "webp"], value="jpg", label="Output Format")
            allow_upsize = gr.Checkbox(label="Allow Upsizing (If smaller than target, enlarge file)", value=False)
            compress_btn = gr.Button("Compress")

    status = gr.Textbox(label="Status / Log", interactive=False)
    download_file = gr.File(label="Download")

    compress_btn.click(
        compress_images,
        inputs=[files_in, target_value, target_unit, output_format, allow_upsize],
        outputs=[download_file, status]
    )

demo.launch()
